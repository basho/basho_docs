---
title: Riak とは
project: riak
version: 0.10.0+
document: tutorial
audience: beginner
keywords: [tutorial, fast-track]
prev: "[[The Riak Fast Track]]"
up:   "[[The Riak Fast Track]]"
next: "[[Building a Dev Environment|Building a Development Environment]]"
versions: false
interest: [
"[[Clusters]]",
"[[Buckets]]",
"[[Eventual Consistency]]",
"[[Vector Clocks]]",
"[[Replication]]"
]
---

このページでは Riak のコアとなるアーキテクチャについて紹介します: アベイラビリティ、フォールトトレランス、平易な操作、予測可能なスケーリングなどです。これらをすでにご存知でしたら、このページをスキップして [[ノード4つのクラスタを作る|Building a Development Environment]] へお進みください。

## Riak クラスタの働き

### Riak ノードとは

Riak クラスタの各ノードは同一で、Riak パッケージの完全なコピーを含んでいます。"マスタ"はありません。より多くのデータを持ったり、特別な機能を持ったノードはありません。この同一性こそ Riak のフォールトトレランスとスケーラビリティの源です。Riak は Erlang によって記述されています。これは、高いアベイラビリティ、並行処理、フォールトトレランスが求められる、非常にスケーラブルなシステムのためにデザインされた言語です。
 
### 整合性ハッシュ

データは整合性ハッシュを用いてノード間に分散されます。整合性ハッシュは、データをクラスタ全体に等しく分散し、新ノードを自動的に追加し、データの移動を最小限に留めます。これによってリスキーなデータベースの"ホットスポット"が劇的に減少し、スケーリング操作の付加が減ります。

整合性ハッシュはどのように動作するのでしょうか？　Riak はデータを単純なキー・バリュー形式で格納します。これらのキーとバリューはバケットと呼ばれるネームスペースに置かれます。新しいキー・バリュー ペアを Riak のバケットに追加するとき、オブジェクトのバケットとキーのコンビネーションがハッシュされます。この結果、バリューは160ビットの整数空間にマッピングされます。この整数空間をリング状にして、データをどの物理マシンに割り当てるかを決めます。

どのようにして？　Riak は整数空間を同じサイズのパーティション(デフォルト 64)に分割します。パーティションはいずれも、全てのバケットおよびキーを担うリングの一部として構成し、ハッシュ化されたものがその中に割り当てられます。パーティションは仮想ノード("vnode")と呼ばれる方法で管理されます。物理マシンは vnode を扱うために等しく分割されます。それぞれ32個のパーティションを持つ、ノードが4つのクラスタがあるとします。下図のように4つの物理マシンがそれぞれ8つの vnode を要求します。この結果、各物理マシンは自身の8つの vnode にすべてのキーを持つようになります。

![A Riak Ring](/images/riak-ring.png)

ハッシュによる分散、物理ノードのキー共有機能によって、Riak はデータを均等に分散させます。

### インテリジェントなレプリケーション

Riak のレプリケーション スキームは、たとえノードがダウンしていても、データの読み出し、書き込み、更新が可能です。レプリカの数は "n" で設定することができます。_n_ が 3 (デフォルト) のときには、オブジェクトは 3 回づつレプリカが作られます。オブジェクトのキーがパーティションに割り当てられたとき、Riak は自動的にデータを、残る 2 つのパーティションへレプリケーションします。

![A Riak Ring](/images/riak-data-distribution.png)

### ストレージが追加されると自動的にデータを再配置

マシンを追加すると、ダウンタイムなしに、データは自動的にリバラウンスされます。新しいマシンはパーティションが所有するデータを引き受けます。既存のクラスタのメンバは関連するパーティション、データを手渡します。新しいノードは、所有するデータが等しくなるまでパーティションを要求し続け、ノードの関係を更新します。このクラスタの状態は、ゴシッププロトコルを用いて全てのノードと共有され、ルートリクエストへガイドします。これはすなわち、クラスタ内のどのノードも、リクエストを受けると何が起きるかについて、開発者は知る必要がなく、どこにデータがあるのかといったややこしいことも考える必要がありません。

## 悪いことが起きたとき

Riak はフォールトトレランス、欠落のないデータを維持し、たとえハードウェアエラーやネットワーク分断が起きてもアベイラビリティを保ちます。Riak にはこのような状況や、その他の障害、たとえばデータのバージョン競合に対処する、さまざまな設定項目があります。

### Hinted Handoff

Hinted handoff とはノードのエラーを処理するものです。ノードにエラーが起きたとき、近くのノードがストレージの操作を引き受けます。エラーノードが復旧したら、近くのノードから更新データを受け取り、元に戻します。これによってデータ書き込みおよび更新のアベイラビリティが保証されます。これは自動化されており、エラー処理という負荷を軽減します。

### バージョンの競合

データのレプリケーションを行うどんなシステムでも、競合がつきものです。たとえば、2つのクライアントが同じオブジェクトを全く同じ時間に更新するとします。または、すべてのアップデートのうちのいくつかが、遅延のためにまだハードウェアまで届いていないとします。Riak ではレプリカは "結果整合性" を持ちます。データは常にアベイラブルなので、全く同じ瞬間にすべてのレプリカが最新のデータを持っているとは限りません。短い時間(通常はミリセカンドオーダ)が経過すると、すべてのものが同期します。

divergence address はどうするのでしょうか。読み出しリクエストが行われると、Riak はすべてのレプリカでオブジェクトを検索します。デフォルトでは、オブジェクトのベクタークロックを参照して、最新のバージョンを返します。ベクタークロックとは、レプリカが作られた際にアタッチされるメタデータです。バージョンを追跡できるように、レプリカがアップデートされるごとに更新されます。また、クライアント側で競合を解消させることもできます。詳細は *[[結果整合性|Eventual Consistency]]* および *[[ベクタークロック|Vector Clocks]]* を参照してください。

### 読み出し修復
読み出しリクエストの結果として古いレプリカを返す場合、整合性を取るために Riak は自動的に同期不良のレプリカをアップデートします。データベースの自己修復機能である読み出し修復機能によって、物理エラーによるノード損失のために "not_found" を返さざる得ないときにも、レプリカのアップデートを行います。*[[読み出し修復の詳細|Replication]]*

### エラー時のデータ読み出しおよび書き込み
Riak では、読み出しのために _r_ 値を、書き込みのために _w_ 値を設定できます。これらの値は、リクエストが成功するためにはいくつのレプリカが応答しなければならないかを制御します。仮に _n_ 値が 3 だとしましょう。しかし、レプリカの入っている物理ノードの1つがダウンしています。r=2 であれば、2個のレプリカが読み出し成功すれば良いのです。これが、ノードがダウン、あるいは遅延していても、Riak が読み出しアベイラビリティを確保できる理由です。書き込みについては _w_ で同じ事を行います。指定しないときのデフォルトは quorum で、半数以上のノードの応答を要します。これらの詳細は Fast Track にて後で説明する [[CAP コントロールを調整する|Tunable CAP Controls in Riak]] にあります。
